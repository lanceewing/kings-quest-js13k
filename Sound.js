class Sound {
  
  /**
   * Constructor for Sound.
   */
  constructor() {
    // Stores the sounds, keyed by the sound name.
    this.sounds = {};

    // The sound module only seems to work in Chrome and Firefox.
    this.active = (!(navigator.userAgent.match(/Opera|OPR\//)));
  }

  /**
   * Initialises the Sounds.
   */
  init() {
    if (this.active) {
        this.add('music', 1, Sound.SONG);
  
        // TODO: Add ZzFX sounds.
      }
  }
  
  /**
   * Generates a sound using the given data and adds it to the stored sounds under the 
   * given name. It will generate the sound multiple times if count is greater than one.
   * This method handles both ZzFX sounds and SoundBox compositions.
   * 
   * @param {Object} name The name of the sound to create. This is the key in the stored sounds.
   * @param {Object} count The number of times to generate the sound.
   * @param {Object} data The data containing the parameters of the sound to be generated.
   */
  add(name, count, data) {
    this.sounds[name] = {tick: 0, count: count, pool: []};
    for (let i = 0; i < count; i++) {
      let audio = new Audio();
      if (data instanceof Array) {
        // If it is an Array, it must be ZzFX data.
        // TODO: Implement.

      } else {
        // Otherwise it is SoundBox data.
        let player = new CPlayer();
        player.init(data);
        // Using only 4 instruments. This saves a bit of space.
        player.generate();
        player.generate();
        player.generate();
        player.generate();
        audio.src = URL.createObjectURL(new Blob([player.createWave()], {type: "audio/wav"}));
        // This is background music, so we set it to loop and turn the volume down a bit.
        audio.loop = true;
        audio.volume = 1.0;
      }
      this.sounds[name].pool.push(audio);
    }
  }
  
  /**
   * Plays the sound of the given name. All sounds are stored as pre-generated Audio 
   * objects. So it is simply a matter of telling it to play. Some sounds have multiple
   * copies, particularly if the sound can be played in quick succession, potentially
   * overlapping. In such a case, it can't use the same Audio, so iterates over a pool
   * of Audios containing the same sound.  
   * 
   * @param {string} name The name of the sound to play.
   */
  play(name) {
    if (this.active) {
      var sound = this.sounds[name];
      sound.pool[sound.tick].play();
    }
  }
  
  /**
   * Pauses the sound of the given name. This is only useful if the count is one, such
   * as for the background music. The current position within the Audio is also set 
   * back to the beginning so that when it is resumed, it starts at the beginning 
   * again.
   *  
   * @param {string} name The name of the sound to pause.
   */
  pause(name) {
    if (this.active) {
      let audio = this.sounds[name].pool[0];
      audio.pause();
      audio.currentTime = 0;
    }
  }
  
  /**
   * This is background music, composed on and generated by the SoundBox.
   */
  static SONG = {
    songData: [
      { // Instrument 0
        i: [
        2, // OSC1_WAVEFORM
        100, // OSC1_VOL
        128, // OSC1_SEMI
        0, // OSC1_XENV
        3, // OSC2_WAVEFORM
        201, // OSC2_VOL
        128, // OSC2_SEMI
        0, // OSC2_DETUNE
        0, // OSC2_XENV
        0, // NOISE_VOL
        0, // ENV_ATTACK
        6, // ENV_SUSTAIN
        29, // ENV_RELEASE
        0, // ARP_CHORD
        0, // ARP_SPEED
        0, // LFO_WAVEFORM
        195, // LFO_AMT
        4, // LFO_FREQ
        1, // LFO_FX_FREQ
        3, // FX_FILTER
        50, // FX_FREQ
        184, // FX_RESONANCE
        119, // FX_DIST
        244, // FX_DRIVE
        147, // FX_PAN_AMT
        6, // FX_PAN_FREQ
        84, // FX_DELAY_AMT
        6 // FX_DELAY_TIME
        ],
        // Patterns
        p: [1,2,1,2,1,2,1,2,2,2,2,2,3,2,3,2],
        // Columns
        c: [
          {n: [130,,135,,139,,142,,140,,139,,135,,137,,135,,139,,137,,135],
           f: []},
          {n: [130,,134,,135,,130,,134,,135,,130,,134,,135,,130,,134,,135],
           f: []},
          {n: [130,,135,,137,,130,,135,,137,,130,,135,,137,,130,,135,,137],
           f: []}
        ]
      },
      { // Instrument 1
        i: [
        2, // OSC1_WAVEFORM
        100, // OSC1_VOL
        128, // OSC1_SEMI
        0, // OSC1_XENV
        3, // OSC2_WAVEFORM
        201, // OSC2_VOL
        128, // OSC2_SEMI
        0, // OSC2_DETUNE
        0, // OSC2_XENV
        0, // NOISE_VOL
        5, // ENV_ATTACK
        6, // ENV_SUSTAIN
        58, // ENV_RELEASE
        0, // ARP_CHORD
        0, // ARP_SPEED
        0, // LFO_WAVEFORM
        195, // LFO_AMT
        6, // LFO_FREQ
        1, // LFO_FX_FREQ
        2, // FX_FILTER
        135, // FX_FREQ
        0, // FX_RESONANCE
        0, // FX_DIST
        32, // FX_DRIVE
        147, // FX_PAN_AMT
        6, // FX_PAN_FREQ
        121, // FX_DELAY_AMT
        6 // FX_DELAY_TIME
        ],
        // Patterns
        p: [1,2,3,4,1,2,3,4,5,4,3,4,5,4,3,4],
        // Columns
        c: [
          {n: [111,,123,,,,111,,123,,,,111,,123,,,,111,,123],
           f: []},
          {n: [115,,115,,,,115,,127,,,,115,,127,,,,115,,127],
           f: []},
          {n: [116,,128,,,,116,,128,,,,116,,128,,,,116,,128],
           f: []},
          {n: [118,,130,,,,118,,130,,,,118,,130,,,,118,,130],
           f: []},
          {n: [120,,132,,,,,,,,,,120,,132],
           f: []}
        ]
      },
      { // Instrument 2
        i: [
        2, // OSC1_WAVEFORM
        192, // OSC1_VOL
        128, // OSC1_SEMI
        0, // OSC1_XENV
        2, // OSC2_WAVEFORM
        192, // OSC2_VOL
        140, // OSC2_SEMI
        18, // OSC2_DETUNE
        0, // OSC2_XENV
        0, // NOISE_VOL
        158, // ENV_ATTACK
        119, // ENV_SUSTAIN
        158, // ENV_RELEASE
        0, // ARP_CHORD
        0, // ARP_SPEED
        0, // LFO_WAVEFORM
        0, // LFO_AMT
        0, // LFO_FREQ
        0, // LFO_FX_FREQ
        2, // FX_FILTER
        5, // FX_FREQ
        0, // FX_RESONANCE
        0, // FX_DIST
        32, // FX_DRIVE
        0, // FX_PAN_AMT
        0, // FX_PAN_FREQ
        24, // FX_DELAY_AMT
        8 // FX_DELAY_TIME
        ],
        // Patterns
        p: [,,,,1,1,1,1,,,,,1,1,1,1],
        // Columns
        c: [
          {n: [142],
           f: []}
        ]
      },
      { // Instrument 3
        i: [
        0, // OSC1_WAVEFORM
        0, // OSC1_VOL
        140, // OSC1_SEMI
        0, // OSC1_XENV
        0, // OSC2_WAVEFORM
        0, // OSC2_VOL
        140, // OSC2_SEMI
        0, // OSC2_DETUNE
        0, // OSC2_XENV
        255, // NOISE_VOL
        158, // ENV_ATTACK
        158, // ENV_SUSTAIN
        158, // ENV_RELEASE
        0, // ARP_CHORD
        0, // ARP_SPEED
        0, // LFO_WAVEFORM
        51, // LFO_AMT
        2, // LFO_FREQ
        1, // LFO_FX_FREQ
        2, // FX_FILTER
        58, // FX_FREQ
        239, // FX_RESONANCE
        0, // FX_DIST
        32, // FX_DRIVE
        88, // FX_PAN_AMT
        1, // FX_PAN_FREQ
        157, // FX_DELAY_AMT
        2 // FX_DELAY_TIME
        ],
        // Patterns
        p: [,,,,,,,,1,1,1,1,1,1,1],
        // Columns
        c: [
          {n: [142],
           f: []}
        ]
      },
    ],
    rowLen: 5513,   // In sample lengths
    patternLen: 24,  // Rows per pattern
    endPattern: 15,  // End pattern
    numChannels: 4  // Number of channels
  };

}